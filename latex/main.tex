\documentclass[a4paper, 11pt]{article}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}

\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    urlcolor=blue,
    citecolor=blue
}

\title{knight_tour_SAT}
\author{wislez.valerian}
\date{November 2025}

\begin{document}
\begin{titlepage}
    \centering
    % --- Logo --- 
    \includegraphics[width=\textwidth]{img/uliege_fsa.png} \\[1 cm]

    % --- Header ---
    \textsc{\Large INFO9015--1 Logic for Computer Science} \\[0.4 cm]

    % --- Title ---
    \rule{\linewidth}{0.2 mm} \\[0.4 cm]
    {\Large \bfseries Project Report --- Knight's Tour SAT solving}
    \rule{\linewidth}{0.2 mm} \\[1.5 cm]

    % --- Minipage ---
    \begin{minipage}[t]{0.49\textwidth}
        \begin{flushleft} \large
            \textbf{Teacher:} \\
                Pascal Fontaine \\[0.5 cm]
            \textbf{Teaching Assistant:} \\
                Tom Clara
        \end{flushleft}
    \end{minipage}
    \hfill 
    \begin{minipage}[t]{0.49\textwidth}
        \begin{flushright} \large
            \textbf{Author:} \\
                Val√©rian Wislez s200825 
        \end{flushright}
    \end{minipage}
    
    \vfill	
    \textsc{\Large Academic Year 2025--2026}
\end{titlepage}

\section{Introduction}

This paper describes the way each question of the project has been solved. A more comprehensive view on the submitted source code can be found at~\cite{knight_tour_github} \footnote{The repository has been made public \textit{after} the submission deadline.}.

\section{Naive solution}
Let $M$ and $N$ be the dimensions of the board and $T = M \cdot N$ the total number of moves.
For every cell $(i,j)$ ($0 \leq i < M$, $0 \leq j < N$) and every time step $t$ ($0 \leq t < T$)
we introduce a Boolean variable representing the knight's position at a given timestep:

\[
x_{i,j,t}
\]

The first attempt at solving the problem involves the following set of constraints:


\begin{enumerate}
    \item A cell can only be occupied at one timestep.\footnote{To ensure only one constraint, one can simply ensure ``at most one'' and ``at least one''.}
    That is, there must be at least one time step for visiting a cell, and visiting a cell at a previous time step $t_1$ enforces to not revisit it at time step $t_2 > t_1$.
    Formally,
    \begin{align}
        \bigvee_{t=0}^{T-1} x_{i,j,t} \\
        \neg x_{i,j,t_1} \vee \neg x_{i,j,t_2}
    \end{align}
    


    \item For a given timestep, the knight can only occupy one cell. 
    Similarly to the previoius constraints, one can force the knight to choose, for each timestep, at least one cell on the board. Then, forbid it to choose another cell for this time step. 
    Formally,

    \begin{align}
        \bigvee_{i=0}^{M-1} \bigvee_{j=0}^{N-1} x_{i,j,t} \\
        \neg x_{i_1,j_1,t} \vee \neg x_{i_2,j_2,t}
    \end{align}
    
    \item Legal moves of the knight restrict its movement. 
    Chess knights can move form a given time step $t$ in $8$ different \textit(L-shaped) directions to another cell in $t + 1$ (provided it does not land outside the chessboard). 
    Let $L$ be the set of available legal moves of the knight at $t$.
    Formally,
    
    \begin{align}
        \neg x_{i,j,t} \bigvee_{\text{$(i', j') \in L$}} x_{i',j',t+1}
    \end{align}

    One can go even a step further to help the SAT solver by specifying the reverse constraints. 
    That is, if a given cell has been reached at $t + 1$, then the knight must have perform one of its legal moves at $t$ and thus it was standing on another cell at $t$. 
    Let $L'$ be the moves available to the knight at time $t + 1$.
    Formally,

    \begin{align}
        \neg x_{i',j',t+1} \bigvee_{\text{$(i, j) \in L'$}} x_{i,j,t}
    \end{align}

\end{enumerate}


%The constraints are implemented in \texttt{add\_legal\_moves\_constraints}, \texttt{add\_cell\_constraints\_naive}, \texttt{add\_time\_constraints\_naive}, \texttt{add\_cell\_constraints\_sequential\_counter}, \texttt{add\_time\_constraints\_sequential\_counter}.

Each set of constraints are implemented in dedicated functions in the code.

\section{Efficient solution}
While the naive solution works well in general, for boards ranging up to \ldots x \ldots it has a quadratic number of constraints for encoding the one cell and one time only.
A more efficient solution would benefit of having less constraints for reducing the search space of the solver.
After doing some research about different encodings~\cite{hoos2007sat} for the ``at-most-one'' family of constraints (refined to ``exactly one'' in this problem), it appeared the naive encoding is actually known as ``pairwise encoding'', and the sequential counter seems to be the one most effective encodings there is.
The sequential counter works by assigning a set of new, auxiliary variables, whose size grows \textit{linearly} with the size of the problem.

This technique can be applied to both the one cell only and one timestep only constraints. 

However, it appears that the sequential counter encoding is not always better than the pairwise encoding, as reported by~\cite{hoos2007sat}
Indeed, because of  

This is implemented in \texttt{}


\section{Counting solutions}
In order to count all solutions for a given board, one simply needs to enumerate all the models found by the SAT solver, for each couple $(i_0, j_0) \in M \times N$. Using the PySAT library, it is easy to do so by calling the \texttt{enum\_models} method after solving the problem and simply count them.

Comparing the results obtained when solving $3 \times 4$ as well as $5 \time 5$ chessboards with the ones showed in~\cite{wikipedia_knights_tour}

This is implemented in \texttt{}

\section{Counting up to symmetry}
The easiest way to count up to symmetry was to enumerate all the solutions, apply symmetries and check whether or not the solution is identical to another solution. 
While this might not be the most effective nor elegant solution, it was fast enough for solving boards up to $5 \times 5$ in a few seconds.

This is implemented in \texttt{}

\section{Finding additional constraints}

First we enumerate all tours that satisfy the basic encoding. 
Each tour is converted into a path, i.e. a sequence of positions indexed by time step $t$, and duplicate paths are discarded.
From the remaining distinct tours, we randomly select one to be the unique tour that will survive.
This guarantees fairness because different runs or different starting cells typically choose different winners.
Finally, we iterate over the other tours in arbitrary order: 
for each alternative that is still compatible with the clauses (constraints) added so far, 
we locate the earliest time step $t \ge 1$ at which it diverges from the chosen tour and force the knight to occupy the chosen tour's position at that step by adding the unit clause $X_{i,j,t}$. 
Because a new clause is introduced only when an alternative would otherwise remain satisfiable, every added clause is necessary: removing it would immediately allow that alternative (and possibly others) back.

\bibliographystyle{plain}
\bibliography{references}

\end{document}
